/* 
yytext: This is a global variable in lex that holds the text of the current token that matches the pattern.
atof(yytext): The atof function converts a string (yytext in this case) to a floating-point number (double).
yylval.value: yylval is a union used in yacc/bison to hold the values of tokens.
The .value part refers to a member of this union that is meant to hold numeric values.
This line assigns the floating-point value of the matched number to yylval.value.


strdup(yytext): The strdup function duplicates the string yytext. This allocates memory and copies the contents of yytext into it.
It's necessary to use strdup to avoid issues where the yytext pointer might be overwritten by subsequent token matches.

yylval.lexeme: Again, yylval is a union used in yacc/bison. The .lexeme part refers to a member of this union that is meant to hold string values (e.g., identifiers).
This line assigns the duplicated string of the matched identifier to yylval.lexeme.

yylval assignments are essential for correctly passing the token values (numeric values and identifiers) from the lexer to the parser,
enabling the parser to process and use these values appropriately in its parsing logic.
*/

%option noyywrap
%{
#include "project.tab.h"  // Include the header file generated by bison
#include <stdlib.h>
#include <string.h>
%}

DIGIT    [0-9]
NUM      {DIGIT}+(\.{DIGIT}+)?

LETTER   [a-zA-Z_]
ID       {LETTER}({LETTER}*{DIGIT}*)

%%
[\n ]+      {/* ignore newline */} ;
(int|INT)                       { return INTEGER; }
(float|FLOAT)                   { return FLOAT; }
(boolean|BOOLEAN)               { return BOOLEAN; }
(varchar|VARCHAR)               { return VARCHAR; }
(DATE|date)                     { return DATE; }
("NOT NULL"|"not null")         { return NOTNULL; }
(UNIQUE|unique)                 { return UNIQUE; }
("PRIMARY KEY"|"primary key")   { return PRIMARYKEY; }
("FOREIGN KEY"|"foreign key")   { return FOREIGNKEY; }
(REFERENCES|references)         { return REFERENCES; }
(CONSTRAINT|constraint)         { return CONSTRAINT; }

{NUM}   {/*yylval.value = atof(yytext);*/
         return NUM;}


("CREATE TABLE"|"create table")    { return CREATETABLE; }
(SELECT|select)                    { return SELECT; }
(FROM|from)                        { return FROM; }
(WHERE|where)                      { return WHERE; }
("GROUP BY"|"group by")            { return GROUPBY; }
("INSERT INTO"|"insert into")      { return INSERT; }
(VALUES|values)                    { return VALUES; }
(CHECK|check)                    { return CHECK; }
(AND|and)               { return AND; }
(OR|or)            { return OR; }

(false|FALSE)              { return FALSE; }
(true|TRUE)                { return TRUE; }

{ID}    {/*yylval.lexeme = strdup(yytext);*/ return ID;}
[-]?{DIGIT}+                {yylval.value = atoi(yytext); return NUM; }
[-]?{DIGIT}+\.{DIGIT}{1,6}  {yylval.value = atof(yytext); return NUM; }


"=="                 { return EQ; }
"!="                 { return NE; }
"<"                  { return LS; }
">"                  { return GR; }
"<="                 { return LE; }
">="                 { return GE; }

","                  { return ','; }
"("                  { return '('; }
")"                  { return ')'; }
[ ]     { /* skip blanks */ };
[\t ]+      {/* ignore whitespace */};

.                 { /* Ignore any other character */ }


%%
