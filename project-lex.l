/* 
yytext: This is a global variable in lex that holds the text of the current token that matches the pattern.
atof(yytext): The atof function converts a string (yytext in this case) to a floating-point number (double).
yylval.value: yylval is a union used in yacc/bison to hold the values of tokens.
The .value part refers to a member of this union that is meant to hold numeric values.
This line assigns the floating-point value of the matched number to yylval.value.


strdup(yytext): The strdup function duplicates the string yytext. This allocates memory and copies the contents of yytext into it.
It's necessary to use strdup to avoid issues where the yytext pointer might be overwritten by subsequent token matches.

yylval.lexeme: Again, yylval is a union used in yacc/bison. The .lexeme part refers to a member of this union that is meant to hold string values (e.g., identifiers).
This line assigns the duplicated string of the matched identifier to yylval.lexeme.

yylval assignments are essential for correctly passing the token values (numeric values and identifiers) from the lexer to the parser,
enabling the parser to process and use these values appropriately in its parsing logic.
*/

%option noyywrap
%{
#include "project.tab.h"  // Include the header file generated by bison
#include <stdlib.h>
#include <string.h>
%}

DIGIT    [0-9]
NUM      {DIGIT}+(\.{DIGIT}+)?

LETTER   [a-zA-Z]
ID       {LETTER}+

%%

"int"               {return INTEGER;}
"float"             {return FLOAT;}
"boolean"           {return BOOLEAN;}
"varchar"           {return VARCHAR;}

{NUM}   {/*yylval.value = atof(yytext);*/
         return NUM;}
{ID}    {/*yylval.lexeme = strdup(yytext);*/ return ID;}
end return 0;

"CREATE TABLE"      {return CREATETABLE;}
"SELECT"            {return SELECT;}
"FROM"              {return FROM;}
"WHERE"             {return WHERE;}
"GROUP BY"          {return GROUPBY;}
"INSERT INTO"       {return INSERT;}
"VALUES"            {return VALUES;}

"false"             {return FALSE;}
"true"              {return TRUE;}

[-]?{DIGIT}+                {yylval.value = atoi(yytext); return NUM; }
[-]?{DIGIT}+\.{DIGIT}{1,6}  {yylval.value = atof(yytext); return NUM; }


"=="                 { return EQ; }
"!="                 { return NE; }
"<"                  { return LS; }
">"                  { return GR; }
"<="                 { return LE; }
">="                 { return GE; }
"AND"                { return AND; }
"OR"                 { return OR; }

","                  { return ','; }
"("                  { return '('; }
")"                  { return ')'; }
[ ]     { /* skip blanks */ };
[\t ]+      {/* ignore whitespace */};
[\n ]+      {/* ignore newline */} ;
.                 { /* Ignore any other character */ }


%%
