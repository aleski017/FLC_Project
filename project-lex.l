/* 
yytext: This is a global variable in lex that holds the text of the current token that matches the pattern.
atof(yytext): The atof function converts a string (yytext in this case) to a floating-point number (double).
yylval.value: yylval is a union used in yacc/bison to hold the values of tokens.
The .value part refers to a member of this union that is meant to hold numeric values.
This line assigns the floating-point value of the matched number to yylval.value.


strdup(yytext): The strdup function duplicates the string yytext. This allocates memory and copies the contents of yytext into it.
It's necessary to use strdup to avoid issues where the yytext pointer might be overwritten by subsequent token matches.

yylval.lexeme: Again, yylval is a union used in yacc/bison. The .lexeme part refers to a member of this union that is meant to hold string values (e.g., identifiers).
This line assigns the duplicated string of the matched identifier to yylval.lexeme.

yylval assignments are essential for correctly passing the token values (numeric values and identifiers) from the lexer to the parser,
enabling the parser to process and use these values appropriately in its parsing logic.
*/

%option noyywrap
%{
#include "project.tab.h"  // Include the header file generated by bison
#include <stdlib.h>
#include <string.h>
%}

DIGIT    [0-9]
NUM      {DIGIT}+(\.{DIGIT}+)?

LETTER   [a-zA-Z_]
ID       {LETTER}({LETTER}*{DIGIT}*)
STRING   \"({LETTER}|{DIGIT}|[_])*\"
BSTRING   \'({LETTER}|{DIGIT}|[_])*\'
 

%%
[\n ]+      {} ;
(int|INT)                       {yylval.lexeme = strdup(yytext); return INTEGER; }
(float|FLOAT)                   { yylval.lexeme = strdup(yytext);return FLOAT; }
("*")		                    { yylval.lexeme = strdup(yytext);return STAR; }
(boolean|BOOLEAN)               { yylval.lexeme = strdup(yytext);return BOOLEAN; }
(varchar|VARCHAR)               { yylval.lexeme = strdup(yytext);return VARCHAR; }
(DATE|date)                     { yylval.lexeme = strdup(yytext);return DATE; }
("NOT NULL"|"not null")         { yylval.lexeme = strdup(yytext);return NOTNULL; }
(UNIQUE|unique)                 { yylval.lexeme = strdup(yytext);return UNIQUE; }
("PRIMARY KEY"|"primary key")   { yylval.lexeme = strdup(yytext);return PRIMARYKEY; }
("FOREIGN KEY"|"foreign key")   { yylval.lexeme = strdup(yytext);return FOREIGNKEY; }
(REFERENCES|references)         { yylval.lexeme = strdup(yytext);return REFERENCES; }
(CONSTRAINT|constraint)         { yylval.lexeme = strdup(yytext);return CONSTRAINT; }

{NUM}   {/*yylval.value = atof(yytext);*/
         yylval.lexeme = strdup(yytext); return NUM;}
{STRING}                     		{ yylval.lexeme = strdup(yytext);return STRINGVALUE; }
{BSTRING}                     		{ yylval.lexeme = strdup(yytext);return STRINGVALUE; }


("CREATE TABLE"|"create table")    { yylval.lexeme = strdup(yytext); return CREATETABLE; }
("ALTER TABLE"|"alter table")      { yylval.lexeme = strdup(yytext);return ALTERTABLE; }
(ALTER|alter)      				   { yylval.lexeme = strdup(yytext);return ALTER; }
(SELECT|select)                    { yylval.lexeme = strdup(yytext);return SELECT; }
(COLUMN|column)                    { yylval.lexeme = strdup(yytext);return COLUMN; }
(RENAME|rename)                    { yylval.lexeme = strdup(yytext);return RENAME; }
(TO|to)                   		   { yylval.lexeme = strdup(yytext);return TO; }
(FROM|from)                        { yylval.lexeme = strdup(yytext);return FROM; }
(WHERE|where)                      { yylval.lexeme = strdup(yytext);return WHERE; }
("GROUP BY"|"group by")            { yylval.lexeme = strdup(yytext);return GROUPBY; }
("INSERT INTO"|"insert into")      { yylval.lexeme = strdup(yytext);return INSERT; }
(VALUES|values)                    { yylval.lexeme = strdup(yytext);return VALUES; }
(CHECK|check)                      { yylval.lexeme = strdup(yytext);return CHECK; }
(AND|and)               		   { yylval.lexeme = strdup(yytext);return AND; }
(OR|or)            				   { yylval.lexeme = strdup(yytext);return OR; }
(DROP|drop)  					   { yylval.lexeme = strdup(yytext);return DROP; }
(DATABASE|database)                { yylval.lexeme = strdup(yytext);return DATABASE; }
("DELETE FROM"|"delete from")      { yylval.lexeme = strdup(yytext);return DELETE_FROM; }
(UPDATE|update)                    { yylval.lexeme = strdup(yytext);return UPDATE; }
(SET|set)                          { yylval.lexeme = strdup(yytext);return SET; }

(false|FALSE)              { yylval.lexeme = strdup(yytext);return FALSE; }
(true|TRUE)                { yylval.lexeme = strdup(yytext);return TRUE; }

{ID}    {yylval.lexeme = strdup(yytext); return ID;}
[-]?{DIGIT}+                {yylval.value = atoi(yytext); return NUM; }
[-]?{DIGIT}+\.{DIGIT}{1,6}  {yylval.value = atof(yytext); return NUM; }


"=="                 { yylval.lexeme = strdup(yytext);return EQ; }
"!="                 { yylval.lexeme = strdup(yytext);return NE; }
"<"                  { yylval.lexeme = strdup(yytext);return LS; }
">"                  { yylval.lexeme = strdup(yytext);return GR; }
"<="                 { yylval.lexeme = strdup(yytext);return LE; }
">="                 { yylval.lexeme = strdup(yytext);return GE; }

","                  { return ','; }
"("                  { return '('; }
")"                  { return ')'; }



%%
